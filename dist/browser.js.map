{"mappings":"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","sources":["<anon>","src/browser.mjs","src/assert.mjs"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $2ddd80d1adc2ea42$exports = {};\n\n$parcel$export($2ddd80d1adc2ea42$exports, \"enable\", () => $2ddd80d1adc2ea42$export$d7c4a0dd6a4567e5);\n$parcel$export($2ddd80d1adc2ea42$exports, \"disable\", () => $2ddd80d1adc2ea42$export$e20fbacbb41798b);\n$parcel$export($2ddd80d1adc2ea42$exports, \"assert\", () => $2ddd80d1adc2ea42$export$a7a9523472993e97);\n$parcel$export($2ddd80d1adc2ea42$exports, \"fails\", () => $2ddd80d1adc2ea42$export$478159de811fd37d);\n$parcel$export($2ddd80d1adc2ea42$exports, \"Optional\", () => $2ddd80d1adc2ea42$export$7acb7b24c478f9c6);\n$parcel$export($2ddd80d1adc2ea42$exports, \"Required\", () => $2ddd80d1adc2ea42$export$1788c381af06add2);\n$parcel$export($2ddd80d1adc2ea42$exports, \"error\", () => $2ddd80d1adc2ea42$export$a3bc9b8ed74fc);\n$parcel$export($2ddd80d1adc2ea42$exports, \"Recommended\", () => $2ddd80d1adc2ea42$export$a83bcf183f49ea9);\n$parcel$export($2ddd80d1adc2ea42$exports, \"oneOf\", () => $2ddd80d1adc2ea42$export$a9a18ae5ba42aeab);\n$parcel$export($2ddd80d1adc2ea42$exports, \"anyOf\", () => $2ddd80d1adc2ea42$export$b26c150f612c10f7);\n$parcel$export($2ddd80d1adc2ea42$exports, \"validURL\", () => $2ddd80d1adc2ea42$export$c6f1a4382426409f);\n$parcel$export($2ddd80d1adc2ea42$exports, \"validEmail\", () => $2ddd80d1adc2ea42$export$9ab921aaffe56820);\n$parcel$export($2ddd80d1adc2ea42$exports, \"instanceOf\", () => $2ddd80d1adc2ea42$export$ca03416d6c9e029e);\n$parcel$export($2ddd80d1adc2ea42$exports, \"not\", () => $2ddd80d1adc2ea42$export$6003a5f097c73977);\n/*\nFIXME: instead of root, pass the current path to each call to fails,\nso that Recommended for instance can tell you which entry is missing\n*/ /**\n * assertEnabled (Boolean) used to toggle whether the assert()\n * method should test assertions or not.\n */ globalThis.assertEnabled = false;\nfunction $2ddd80d1adc2ea42$export$d7c4a0dd6a4567e5() {\n    globalThis.assertEnabled = true;\n}\nfunction $2ddd80d1adc2ea42$export$e20fbacbb41798b() {\n    globalThis.assertEnabled = false;\n}\nconst $2ddd80d1adc2ea42$export$a7a9523472993e97 = (source, test)=>{\n    if (globalThis.assertEnabled) {\n        let problems = $2ddd80d1adc2ea42$export$478159de811fd37d(source, test);\n        if (problems) throw new $2ddd80d1adc2ea42$var$assertError(\"Assertions failed\", problems, source);\n    }\n};\nconst $2ddd80d1adc2ea42$export$7acb7b24c478f9c6 = (pattern)=>(data, root, path)=>{\n        if (data == null || typeof data == \"undefined\") return false;\n        else return $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path);\n    };\nconst $2ddd80d1adc2ea42$export$1788c381af06add2 = (pattern)=>(data, root, path)=>{\n        if (data == null || typeof data == \"undefined\") return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is required\", data, pattern || \"any value\", path);\n        else if (typeof pattern != \"undefined\") return $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path);\n        else return false;\n    };\nconst $2ddd80d1adc2ea42$export$a83bcf183f49ea9 = (pattern)=>(data, root, path)=>{\n        if (data == null || typeof data == \"undefined\") {\n            console.warn(\"data does not contain recommended value\", data, pattern, path);\n            return false;\n        } else return $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path);\n    };\nconst $2ddd80d1adc2ea42$export$a9a18ae5ba42aeab = (...patterns)=>(data, root, path)=>{\n        for (let pattern of patterns){\n            if (!$2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path)) return false;\n        }\n        return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data does not match oneOf patterns\", data, patterns, path);\n    };\nconst $2ddd80d1adc2ea42$export$b26c150f612c10f7 = (...patterns)=>(data, root, path)=>{\n        if (!Array.isArray(data)) return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not an array\", data, \"anyOf\", path);\n        for (let value of data){\n            if ($2ddd80d1adc2ea42$export$a9a18ae5ba42aeab(...patterns)(value)) return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data does not match anyOf patterns\", value, patterns, path);\n        }\n        return false;\n    };\nfunction $2ddd80d1adc2ea42$export$c6f1a4382426409f(data, root, path) {\n    try {\n        if (data instanceof URL) data = data.href;\n        let url = new URL(data);\n        if (url.href != data) {\n            if (url.href + \"/\" == data || url.href == data + \"/\") return false // new URL() always adds a / as path\n            ;\n            return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a valid url\", data, \"validURL\", path);\n        }\n    } catch (e) {\n        return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a valid url\", data, \"validURL\", path);\n    }\n    return false;\n}\nfunction $2ddd80d1adc2ea42$export$9ab921aaffe56820(data, root, path) {\n    if (/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data)) return false // data matches email regex\n    ;\n    return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a valid email\", data, \"validEmail\", path);\n}\nconst $2ddd80d1adc2ea42$export$ca03416d6c9e029e = (constructor)=>(data, root, path)=>!(data instanceof constructor) ? $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not an instanceof pattern\", data, constructor, path) : false;\nconst $2ddd80d1adc2ea42$export$6003a5f097c73977 = (pattern)=>(data, root, path)=>{\n        let problems = $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path);\n        if (!problems) return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data matches pattern, when required not to\", data, pattern, path);\n        return false;\n    };\nfunction $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path = \"\") {\n    if (!root) root = data;\n    let problems = [];\n    if (pattern === Boolean) {\n        if (typeof data != \"boolean\" && !(data instanceof Boolean)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a boolean\", data, pattern, path));\n    } else if (pattern === Number) {\n        if (typeof data != \"number\" && !(data instanceof Number)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a number\", data, pattern, path));\n    } else if (pattern === String) {\n        if (typeof data != \"string\" && !(data instanceof String)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a string\", data, pattern, path));\n        if (data == \"\") problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is an empty string, which is not allowed\", data, pattern, path));\n    } else if (pattern instanceof RegExp) {\n        if (Array.isArray(data)) {\n            let index = data.findIndex((element, index)=>$2ddd80d1adc2ea42$export$478159de811fd37d(element, pattern, root, path + \"[\" + index + \"]\"));\n            if (index > -1) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data[\" + index + \"] does not match pattern\", data[index], pattern, path + \"[\" + index + \"]\"));\n        } else if (typeof data == \"undefined\") problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is undefined, should match pattern\", data, pattern, path));\n        else if (!pattern.test(data)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data does not match pattern\", data, pattern, path));\n    } else if (pattern instanceof Function) {\n        let problem = pattern(data, root, path);\n        if (problem) {\n            if (Array.isArray(problem)) problems = problems.concat(problem);\n            else problems.push(problem);\n        }\n    } else if (Array.isArray(pattern)) {\n        if (!Array.isArray(data)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not an array\", data, [], path));\n        for (let p of pattern)for (let index of data.keys()){\n            let problem = $2ddd80d1adc2ea42$export$478159de811fd37d(data[index], p, root, path + \"[\" + index + \"]\");\n            if (Array.isArray(problem)) problems = problems.concat(problem);\n            else if (problem) problems.push(problem);\n        }\n    } else if (pattern && typeof pattern == \"object\") {\n        if (Array.isArray(data)) {\n            let index = data.findIndex((element, index)=>$2ddd80d1adc2ea42$export$478159de811fd37d(element, pattern, root, path + \"[\" + index + \"]\"));\n            if (index > -1) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data[\" + index + \"] does not match pattern\", data[index], pattern, path + \"[\" + index + \"]\"));\n        } else if (!data || typeof data != \"object\") problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not an object, pattern is\", data, pattern, path));\n        else {\n            if (data instanceof URLSearchParams) data = Object.fromEntries(data);\n            if (pattern instanceof Function) {\n                let result = $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path);\n                if (result) problems = problems.concat(result);\n            } else for (const [wKey, wVal] of Object.entries(pattern)){\n                let result = $2ddd80d1adc2ea42$export$478159de811fd37d(data[wKey], wVal, root, path + \".\" + wKey);\n                if (result) problems = problems.concat(result);\n            }\n        }\n    } else if (pattern != data) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data and pattern are not equal\", data, pattern, path));\n    if (problems.length) return problems;\n    return false;\n}\n/**\n * Class used in assert() to add problems found and details to the error object\n */ class $2ddd80d1adc2ea42$var$assertError extends Error {\n    constructor(message, problems, ...details){\n        super(message);\n        this.problems = problems;\n        this.details = details;\n    }\n}\nfunction $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(message, found, expected, path) {\n    return {\n        message: message,\n        found: found,\n        expected: expected,\n        path: path\n    };\n}\n\n\nglobalThis.assert = $2ddd80d1adc2ea42$exports;\n\n\n//# sourceMappingURL=browser.js.map\n","import * as assert from './assert.mjs'\n\nglobalThis.assert = assert\n","/*\nFIXME: instead of root, pass the current path to each call to fails,\nso that Recommended for instance can tell you which entry is missing\n*/\n\n/**\n * assertEnabled (Boolean) used to toggle whether the assert()\n * method should test assertions or not.\n */\nglobalThis.assertEnabled = false\n\n/**\n * Enables assertion testing with assert()\n */\nexport function enable() {\n\tglobalThis.assertEnabled = true\n}\n\n/**\n * Disables assertion testing with assert()\n */\nexport function disable() {\n\tglobalThis.assertEnabled = false\n}\n\n/**\n * This function will check the source for the assertions in test, if\n * assertion checking is enabled globally.\n * If it is, and any assertion fails, it will throw an assertError\n * with a list of problems and other details.\n */\nexport const assert = (source, test) => {\n\tif (globalThis.assertEnabled) {\n\t\tlet problems = fails(source,test)\n\t\tif (problems) {\n\t\t\tthrow new assertError('Assertions failed', problems, source)\n\t\t}\n\t}\n}\n\n/**\n * Tests a given value against a pattern, only if the value is not null or undefined\n */\nexport const Optional = (pattern) => \n\t(data, root, path) => {\n\t\tif (data==null || typeof data == 'undefined') {\n\t\t\treturn false \n\t\t} else {\n\t\t\treturn fails(data, pattern, root, path)\n\t\t}\n\t}\n\n/**\n * Tests a given value against a pattern, always.\n */\nexport const Required = (pattern) =>\n\t(data, root, path) => {\n\t\tif (data==null || typeof data == 'undefined') {\n\t\t\treturn error('data is required', data, pattern || 'any value', path)\n\t\t} else if (typeof pattern != 'undefined') {\n\t\t\treturn fails(data, pattern, root, path)\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n/**\n * Tests a given value against a pattern, only if the value is not null or undefined\n * If null or undefined, it does print a warning to the console.\n */\nexport const Recommended = (pattern) =>\n\t(data, root, path) => {\n\t\tif (data==null || typeof data == 'undefined') {\n\t\t\tconsole.warn('data does not contain recommended value', data, pattern, path)\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn fails(data, pattern, root, path)\n\t\t}\n\t}\n\n/**\n * Tests a given value against a set of patterns, untill one succeeds\n * Returns an error if none succeed\n */\nexport const oneOf = (...patterns) => \n\t(data, root, path) => {\n\t\tfor(let pattern of patterns) {\n\t\t\tif (!fails(data, pattern, root, path)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn error('data does not match oneOf patterns', data, patterns, path)\n\t}\n\n/**\n * Tests a given array of values against a set of patterns\n * If any value does not match one of the patterns, it will return an error\n * If not given an array to test, it will return an error\n */\nexport const anyOf = (...patterns) =>\n\t(data, root, path) => {\n\t\tif (!Array.isArray(data)) {\n\t\t\treturn error('data is not an array',data,'anyOf',path)\n\t\t}\n\t\tfor (let value of data) {\n\t\t\tif (oneOf(...patterns)(value)) {\n\t\t\t\treturn error('data does not match anyOf patterns',value,patterns,path)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n/**\n * Tests a given value to see if it is a valid (and absolute) URL, by\n * parsing it with the URL() constructor, and then testing the href\n * value to be equal to the initial value.\n */\nexport function validURL(data, root, path) {\n\ttry {\n\t\tif (data instanceof URL) {\n\t\t\tdata = data.href\n\t\t}\n\t\tlet url = new URL(data)\n\t\tif (url.href!=data) {\n\t\t\tif (url.href+'/'==data || url.href==data+'/') {\n\t\t\t\treturn false // new URL() always adds a / as path\n\t\t\t}\n\t\t\treturn error('data is not a valid url',data,'validURL',path)\n\t\t}\n\t} catch(e) {\n\t\treturn error('data is not a valid url',data,'validURL',path)\n\t}\n\treturn false\n}\n\n/**\n * Tests a given value to see if it looks like a valid email address, by\n * testing it against a regular expression. So there are no guarantees that\n * it is an actual working email address, just that it looks like one.\n */\nexport function validEmail(data, root, path) {\n\tif (/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data)) {\n\t\treturn false // data matches email regex\n\t}\n\treturn error('data is not a valid email',data,'validEmail',path)\n}\n\n/**\n * Tests a given value to see if it is an object which is an instance of the given\n * constructor\n */\nexport const instanceOf = (constructor) =>\n\t(data, root, path) => !(data instanceof constructor) \n\t\t? error('data is not an instanceof pattern',data,constructor,path)\n\t\t: false\n\n/**\n * Runs the given test pattern on a value, if the test succeeds, it fails\n * the not() test.\n */\nexport const not = (pattern) =>\n\t(data, root, path) => {\n\t\tlet problems = fails(data, pattern, root, path) \n\t\tif (!problems) {\n\t\t\treturn error('data matches pattern, when required not to', data, pattern, path)\n\t\t}\n\t\treturn false\n\t}\n\n/**\n * returns an array of problems if the data fails to satisfy \n * the assertions in the given pattern, false otherwise\n * @param {any} data    The data to match\n * @param {any} pattern The pattern to match\n * @param {any} root    Root object for assertions, set to data by default\n * @return {Array|false} Array with problems if the pattern fails, false otherwise\n */\nexport function fails(data, pattern, root, path='') {\n\tif (!root) {\n\t\troot = data\n\t}\n\tlet problems = []\n\tif (pattern === Boolean) {\n\t\tif (typeof data != 'boolean' && !(data instanceof Boolean)) {\n\t\t\tproblems.push(error('data is not a boolean', data, pattern, path))\n\t\t}\t\t\n\t} else if (pattern === Number) {\n\t\tif (typeof data != 'number' && !(data instanceof Number)) {\n\t\t\tproblems.push(error('data is not a number', data, pattern, path))\n\t\t}\n\t} else if (pattern === String) {\n\t\tif (typeof data != 'string' && !(data instanceof String)) {\n\t\t\tproblems.push(error('data is not a string', data, pattern, path))\n\t\t}\n\t\tif (data == \"\") {\n\t\t\tproblems.push(error('data is an empty string, which is not allowed', data, pattern, path))\n\t\t}\n\t} else if (pattern instanceof RegExp) {\n    \tif (Array.isArray(data)) {\n\t\t\tlet index = data.findIndex((element,index) => fails(element,pattern,root,path+'['+index+']'))\n            if (index>-1) {\n            \tproblems.push(error('data['+index+'] does not match pattern', data[index], pattern, path+'['+index+']'))\n            }\n        } else if (typeof data == 'undefined') {\n        \tproblems.push(error('data is undefined, should match pattern', data, pattern, path))\n    \t} else if (!pattern.test(data)) {\n        \tproblems.push(error('data does not match pattern', data, pattern, path))\n        }\n    } else if (pattern instanceof Function) {\n        let problem = pattern(data, root, path)\n        if (problem) {\n        \tif (Array.isArray(problem)) {\n        \t\tproblems = problems.concat(problem)\n        \t} else {\n\t        \tproblems.push(problem)\n\t        }\n        }\n    } else if (Array.isArray(pattern)) {\n\t\tif (!Array.isArray(data)) {\n\t\t\tproblems.push(error('data is not an array',data,[],path))\n\t\t}\n\t\tfor (let p of pattern) {\n\t\t\tfor (let index of data.keys()) {\n\t\t\t\tlet problem = fails(data[index], p, root, path+'['+index+']')\n\t\t\t\tif (Array.isArray(problem)) {\n\t\t\t\t\tproblems = problems.concat(problem)\n\t\t\t\t} else if (problem) {\n\t\t\t\t\tproblems.push(problem)\n\t\t\t\t}\n\t\t\t}\n    \t}\n    } else if (pattern && typeof pattern == 'object') {\n        if (Array.isArray(data)) {\n            let index = data.findIndex((element,index) => fails(element,pattern,root,path+'['+index+']'))\n            if (index>-1) {\n            \tproblems.push(error('data['+index+'] does not match pattern', data[index], pattern, path+'['+index+']'))\n            }\n        } else if (!data || typeof data != 'object') {\n        \tproblems.push(error('data is not an object, pattern is', data, pattern, path))\n        } else {\n        \tif (data instanceof URLSearchParams) {\n        \t\tdata = Object.fromEntries(data)\n        \t}\n        \tif (pattern instanceof Function) {\n        \t\tlet result = fails(data, pattern, root, path)\n\t            if (result) {\n\t            \tproblems = problems.concat(result)\n\t            }\n        \t} else {\n\t\t        for (const [wKey, wVal] of Object.entries(pattern)) {\n\t\t            let result = fails(data[wKey], wVal, root, path+'.'+wKey)\n\t\t            if (result) {\n\t\t            \tproblems = problems.concat(result)\n\t\t            }\n\t\t        }\n\t\t    }\n\t    }\n    } else {\n    \tif (pattern!=data) {\n    \t\tproblems.push(error('data and pattern are not equal', data, pattern, path))\n    \t}\n    }\n    if (problems.length) {\n    \treturn problems\n    }\n    return false\n}\n\n\n/**\n * Class used in assert() to add problems found and details to the error object\n */\nclass assertError extends Error {\n\tconstructor(message, problems, ...details) {\n\t\tsuper(message)\n\t\tthis.problems = problems\n\t\tthis.details = details\n\t}\n}\n\n/**\n * Returns an object with message, found and expected properties\n */ \nexport function error(message, found, expected, path) {\n\treturn {\n\t\tmessage,\n\t\tfound,\n\t\texpected,\n\t\tpath\n\t}\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$2ddd80d1adc2ea42$exports","$2ddd80d1adc2ea42$export$d7c4a0dd6a4567e5","globalThis","assertEnabled","$2ddd80d1adc2ea42$export$e20fbacbb41798b","$2ddd80d1adc2ea42$export$a7a9523472993e97","$2ddd80d1adc2ea42$export$478159de811fd37d","$2ddd80d1adc2ea42$export$7acb7b24c478f9c6","$2ddd80d1adc2ea42$export$1788c381af06add2","$2ddd80d1adc2ea42$export$a3bc9b8ed74fc","$2ddd80d1adc2ea42$export$a83bcf183f49ea9","$2ddd80d1adc2ea42$export$a9a18ae5ba42aeab","$2ddd80d1adc2ea42$export$b26c150f612c10f7","$2ddd80d1adc2ea42$export$c6f1a4382426409f","$2ddd80d1adc2ea42$export$9ab921aaffe56820","$2ddd80d1adc2ea42$export$ca03416d6c9e029e","$2ddd80d1adc2ea42$export$6003a5f097c73977","source","test","problems","$2ddd80d1adc2ea42$var$assertError","pattern","data","root","path","console","warn","patterns","Array","isArray","value","URL","href","url","constructor","Boolean","push","Number","String","RegExp","index","findIndex","element","Function","problem","concat","p","keys","URLSearchParams","fromEntries","result","wKey","wVal","entries","length","Error","message","details","found","expected","assert"],"version":3,"file":"browser.js.map","sourceRoot":"../"}