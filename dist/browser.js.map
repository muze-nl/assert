{"mappings":"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","sources":["<anon>","src/browser.mjs","src/assert.mjs"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $2ddd80d1adc2ea42$exports = {};\n\n$parcel$export($2ddd80d1adc2ea42$exports, \"enable\", () => $2ddd80d1adc2ea42$export$d7c4a0dd6a4567e5);\n$parcel$export($2ddd80d1adc2ea42$exports, \"disable\", () => $2ddd80d1adc2ea42$export$e20fbacbb41798b);\n$parcel$export($2ddd80d1adc2ea42$exports, \"assert\", () => $2ddd80d1adc2ea42$export$a7a9523472993e97);\n$parcel$export($2ddd80d1adc2ea42$exports, \"fails\", () => $2ddd80d1adc2ea42$export$478159de811fd37d);\n$parcel$export($2ddd80d1adc2ea42$exports, \"Optional\", () => $2ddd80d1adc2ea42$export$7acb7b24c478f9c6);\n$parcel$export($2ddd80d1adc2ea42$exports, \"Required\", () => $2ddd80d1adc2ea42$export$1788c381af06add2);\n$parcel$export($2ddd80d1adc2ea42$exports, \"error\", () => $2ddd80d1adc2ea42$export$a3bc9b8ed74fc);\n$parcel$export($2ddd80d1adc2ea42$exports, \"Recommended\", () => $2ddd80d1adc2ea42$export$a83bcf183f49ea9);\n$parcel$export($2ddd80d1adc2ea42$exports, \"oneOf\", () => $2ddd80d1adc2ea42$export$a9a18ae5ba42aeab);\n$parcel$export($2ddd80d1adc2ea42$exports, \"anyOf\", () => $2ddd80d1adc2ea42$export$b26c150f612c10f7);\n$parcel$export($2ddd80d1adc2ea42$exports, \"allOf\", () => $2ddd80d1adc2ea42$export$f632c79c8963a286);\n$parcel$export($2ddd80d1adc2ea42$exports, \"validURL\", () => $2ddd80d1adc2ea42$export$c6f1a4382426409f);\n$parcel$export($2ddd80d1adc2ea42$exports, \"validEmail\", () => $2ddd80d1adc2ea42$export$9ab921aaffe56820);\n$parcel$export($2ddd80d1adc2ea42$exports, \"instanceOf\", () => $2ddd80d1adc2ea42$export$ca03416d6c9e029e);\n$parcel$export($2ddd80d1adc2ea42$exports, \"not\", () => $2ddd80d1adc2ea42$export$6003a5f097c73977);\n/*\nFIXME: Optional() fails if the pattern is not set and the value is\nTODO: scratch: Required() and Optional() and Recommended() should test multiple patterns\n  instead: add allOf(...patterns) function\nTODO: add assertExplain global flag, so that if assert() fails, you can call explain() with\n  the same pattern and it will return text explanation of why it failed, each assertion function must \n  then check assertExplain, and return a text explanation of what fails or succeeds\n  top level can then filter to show only the failures\n  (so that not(x) can show the succeeds message of x)\n*/ /**\n * assertEnabled (Boolean) used to toggle whether the assert()\n * method should test assertions or not.\n */ globalThis.assertEnabled = false;\nfunction $2ddd80d1adc2ea42$export$d7c4a0dd6a4567e5() {\n    globalThis.assertEnabled = true;\n}\nfunction $2ddd80d1adc2ea42$export$e20fbacbb41798b() {\n    globalThis.assertEnabled = false;\n}\nfunction $2ddd80d1adc2ea42$export$a7a9523472993e97(source, test) {\n    if (globalThis.assertEnabled) {\n        let problems = $2ddd80d1adc2ea42$export$478159de811fd37d(source, test);\n        if (problems) throw new $2ddd80d1adc2ea42$var$assertError(\"Assertions failed\", problems, source);\n    }\n}\nfunction $2ddd80d1adc2ea42$export$7acb7b24c478f9c6(pattern) {\n    return function _Optional(data, root, path) {\n        if (data == null || typeof data == \"undefined\") return false;\n        else return $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path);\n    };\n}\nfunction $2ddd80d1adc2ea42$export$1788c381af06add2(pattern) {\n    return function _Required(data, root, path) {\n        if (data == null || typeof data == \"undefined\") return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is required\", data, pattern || \"any value\", path);\n        else if (typeof pattern != \"undefined\") return $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path);\n        else return false;\n    };\n}\nfunction $2ddd80d1adc2ea42$export$a83bcf183f49ea9(...pattern) {\n    return function _Recommended(data, root, path) {\n        if (data == null || typeof data == \"undefined\") {\n            console.warn(\"data does not contain recommended value\", data, pattern, path);\n            return false;\n        } else return $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path);\n    };\n}\nfunction $2ddd80d1adc2ea42$export$a9a18ae5ba42aeab(...patterns) {\n    return function _oneOf(data, root, path) {\n        for (let pattern of patterns){\n            if (!$2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path)) return false;\n        }\n        return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data does not match oneOf patterns\", data, patterns, path);\n    };\n}\nfunction $2ddd80d1adc2ea42$export$b26c150f612c10f7(...patterns) {\n    return function _anyOf(data, root, path) {\n        if (!Array.isArray(data)) return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not an array\", data, \"anyOf\", path);\n        for (let value of data){\n            if ($2ddd80d1adc2ea42$export$a9a18ae5ba42aeab(...patterns)(value)) return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data does not match anyOf patterns\", value, patterns, path);\n        }\n        return false;\n    };\n}\nfunction $2ddd80d1adc2ea42$export$f632c79c8963a286(...patterns) {\n    return function _allOf(data, root, path) {\n        let problems = [];\n        for (let pattern of patterns)problems = problems.concat($2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path));\n        problems = problems.filter(Boolean);\n        if (problems.length) return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data does not match all given patterns\", data, patterns, path, problems);\n    };\n}\nfunction $2ddd80d1adc2ea42$export$c6f1a4382426409f(data, root, path) {\n    try {\n        if (data instanceof URL) data = data.href;\n        let url = new URL(data);\n        if (url.href != data) {\n            if (!(url.href + \"/\" == data || url.href == data + \"/\")) // new URL() always adds a / as path\n            return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a valid url\", data, \"validURL\", path);\n        }\n    } catch (e) {\n        return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a valid url\", data, \"validURL\", path);\n    }\n}\nfunction $2ddd80d1adc2ea42$export$9ab921aaffe56820(data, root, path) {\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data)) return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a valid email\", data, \"validEmail\", path);\n}\nfunction $2ddd80d1adc2ea42$export$ca03416d6c9e029e(constructor) {\n    return function _instanceOf(data, root, path) {\n        if (!(data instanceof constructor)) return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not an instanceof pattern\", data, constructor, path);\n    };\n}\nfunction $2ddd80d1adc2ea42$export$6003a5f097c73977(pattern) {\n    return function _not(data, root, path) {\n        if (!$2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path)) return $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data matches pattern, when required not to\", data, pattern, path);\n    };\n}\nfunction $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path = \"\") {\n    if (!root) root = data;\n    let problems = [];\n    if (pattern === Boolean) {\n        if (typeof data != \"boolean\" && !(data instanceof Boolean)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a boolean\", data, pattern, path));\n    } else if (pattern === Number) {\n        if (typeof data != \"number\" && !(data instanceof Number)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a number\", data, pattern, path));\n    } else if (pattern === String) {\n        if (typeof data != \"string\" && !(data instanceof String)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not a string\", data, pattern, path));\n        if (data == \"\") problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is an empty string, which is not allowed\", data, pattern, path));\n    } else if (pattern instanceof RegExp) {\n        if (Array.isArray(data)) {\n            let index = data.findIndex((element, index)=>$2ddd80d1adc2ea42$export$478159de811fd37d(element, pattern, root, path + \"[\" + index + \"]\"));\n            if (index > -1) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data[\" + index + \"] does not match pattern\", data[index], pattern, path + \"[\" + index + \"]\"));\n        } else if (typeof data == \"undefined\") problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is undefined, should match pattern\", data, pattern, path));\n        else if (!pattern.test(data)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data does not match pattern\", data, pattern, path));\n    } else if (pattern instanceof Function) {\n        let problem = pattern(data, root, path);\n        if (problem) {\n            if (Array.isArray(problem)) problems = problems.concat(problem);\n            else problems.push(problem);\n        }\n    } else if (Array.isArray(pattern)) {\n        if (!Array.isArray(data)) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not an array\", data, [], path));\n        for (let p of pattern)for (let index of data.keys()){\n            let problem = $2ddd80d1adc2ea42$export$478159de811fd37d(data[index], p, root, path + \"[\" + index + \"]\");\n            if (Array.isArray(problem)) problems = problems.concat(problem);\n            else if (problem) problems.push(problem);\n        }\n    } else if (pattern && typeof pattern == \"object\") {\n        if (Array.isArray(data)) {\n            let index = data.findIndex((element, index)=>$2ddd80d1adc2ea42$export$478159de811fd37d(element, pattern, root, path + \"[\" + index + \"]\"));\n            if (index > -1) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data[\" + index + \"] does not match pattern\", data[index], pattern, path + \"[\" + index + \"]\"));\n        } else if (!data || typeof data != \"object\") problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data is not an object, pattern is\", data, pattern, path));\n        else {\n            if (data instanceof URLSearchParams) data = Object.fromEntries(data);\n            if (pattern instanceof Function) {\n                let result = $2ddd80d1adc2ea42$export$478159de811fd37d(data, pattern, root, path);\n                if (result) problems = problems.concat(result);\n            } else for (const [wKey, wVal] of Object.entries(pattern)){\n                let result = $2ddd80d1adc2ea42$export$478159de811fd37d(data[wKey], wVal, root, path + \".\" + wKey);\n                if (result) problems = problems.concat(result);\n            }\n        }\n    } else if (pattern != data) problems.push($2ddd80d1adc2ea42$export$a3bc9b8ed74fc(\"data and pattern are not equal\", data, pattern, path));\n    if (problems.length) return problems;\n    return false;\n}\n/**\n * Class used in assert() to add problems found and details to the error object\n */ class $2ddd80d1adc2ea42$var$assertError extends Error {\n    constructor(message, problems, ...details){\n        super(message);\n        this.problems = problems;\n        this.details = details;\n    }\n}\nfunction $2ddd80d1adc2ea42$export$a3bc9b8ed74fc(message, found, expected, path, problems) {\n    let result = {\n        message: message,\n        found: found,\n        expected: expected,\n        path: path\n    };\n    if (problems) result.problems = problems;\n    return result;\n}\n\n\nglobalThis.assert = $2ddd80d1adc2ea42$exports;\n\n\n//# sourceMappingURL=browser.js.map\n","import * as assert from './assert.mjs'\n\nglobalThis.assert = assert\n","/*\nFIXME: Optional() fails if the pattern is not set and the value is\nTODO: scratch: Required() and Optional() and Recommended() should test multiple patterns\n  instead: add allOf(...patterns) function\nTODO: add assertExplain global flag, so that if assert() fails, you can call explain() with\n  the same pattern and it will return text explanation of why it failed, each assertion function must \n  then check assertExplain, and return a text explanation of what fails or succeeds\n  top level can then filter to show only the failures\n  (so that not(x) can show the succeeds message of x)\n*/\n\n/**\n * assertEnabled (Boolean) used to toggle whether the assert()\n * method should test assertions or not.\n */\nglobalThis.assertEnabled = false\n\n/**\n * Enables assertion testing with assert()\n */\nexport function enable() {\n\tglobalThis.assertEnabled = true\n}\n\n/**\n * Disables assertion testing with assert()\n */\nexport function disable() {\n\tglobalThis.assertEnabled = false\n}\n\n/**\n * This function will check the source for the assertions in test, if\n * assertion checking is enabled globally.\n * If it is, and any assertion fails, it will throw an assertError\n * with a list of problems and other details.\n */\nexport function assert(source, test) {\n\tif (globalThis.assertEnabled) {\n\t\tlet problems = fails(source,test)\n\t\tif (problems) {\n\t\t\tthrow new assertError('Assertions failed', problems, source)\n\t\t}\n\t}\n}\n\n/**\n * Tests a given value against a pattern, only if the value is not null or undefined\n */\nexport function Optional(pattern) {\n\treturn function _Optional(data, root, path) {\n\t\tif (data==null || typeof data == 'undefined') {\n\t\t\treturn false \n\t\t} else {\n\t\t\treturn fails(data, pattern, root, path)\n\t\t}\n\t}\n}\n\n/**\n * Tests a given value against a pattern, always.\n */\nexport function Required(pattern) {\n\treturn function _Required(data, root, path) {\n\t\tif (data==null || typeof data == 'undefined') {\n\t\t\treturn error('data is required', data, pattern || 'any value', path)\n\t\t} else if (typeof pattern != 'undefined') {\n\t\t\treturn fails(data, pattern, root, path)\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n}\n\n/**\n * Tests a given value against a pattern, only if the value is not null or undefined\n * If null or undefined, it does print a warning to the console.\n */\nexport function Recommended(...pattern) {\n\treturn function _Recommended(data, root, path) {\n\t\tif (data==null || typeof data == 'undefined') {\n\t\t\tconsole.warn('data does not contain recommended value', data, pattern, path)\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn fails(data, pattern, root, path)\n\t\t}\n\t}\n}\n\n/**\n * Tests a given value against a set of patterns, untill one succeeds\n * Returns an error if none succeed\n */\nexport function oneOf(...patterns) { \n\treturn function _oneOf(data, root, path) {\n\t\tfor(let pattern of patterns) {\n\t\t\tif (!fails(data, pattern, root, path)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn error('data does not match oneOf patterns', data, patterns, path)\n\t}\n}\n\n/**\n * Tests a given array of values against a set of patterns\n * If any value does not match one of the patterns, it will return an error\n * If not given an array to test, it will return an error\n */\nexport function anyOf(...patterns) {\n\treturn function _anyOf(data, root, path) {\n\t\tif (!Array.isArray(data)) {\n\t\t\treturn error('data is not an array',data,'anyOf',path)\n\t\t}\n\t\tfor (let value of data) {\n\t\t\tif (oneOf(...patterns)(value)) {\n\t\t\t\treturn error('data does not match anyOf patterns',value,patterns,path)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\nexport function allOf(...patterns) {\n\treturn function _allOf(data, root, path) {\n\t\tlet problems = []\n\t\tfor (let pattern of patterns) {\n\t\t\tproblems = problems.concat(fails(data, pattern, root, path))\n\t\t}\n\t\tproblems = problems.filter(Boolean)\n\t\tif (problems.length) {\n\t\t\treturn error('data does not match all given patterns', data, patterns, path, problems)\n\t\t}\n\t}\n}\n\n/**\n * Tests a given value to see if it is a valid (and absolute) URL, by\n * parsing it with the URL() constructor, and then testing the href\n * value to be equal to the initial value.\n */\nexport function validURL(data, root, path) {\n\ttry {\n\t\tif (data instanceof URL) {\n\t\t\tdata = data.href\n\t\t}\n\t\tlet url = new URL(data)\n\t\tif (url.href!=data) {\n\t\t\tif (!(url.href+'/'==data || url.href==data+'/')) {\n\t\t\t\t// new URL() always adds a / as path\n\t\t\t\treturn error('data is not a valid url',data,'validURL',path)\n\t\t\t}\n\t\t}\n\t} catch(e) {\n\t\treturn error('data is not a valid url',data,'validURL',path)\n\t}\n}\n\n/**\n * Tests a given value to see if it looks like a valid email address, by\n * testing it against a regular expression. So there are no guarantees that\n * it is an actual working email address, just that it looks like one.\n */\nexport function validEmail(data, root, path) {\n\tif (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data)) {\n\t\treturn error('data is not a valid email',data,'validEmail',path)\n\t}\n}\n\n/**\n * Tests a given value to see if it is an object which is an instance of the given\n * constructor\n */\nexport function instanceOf(constructor) {\n\treturn function _instanceOf(data, root, path) {\n\t\tif (!(data instanceof constructor)) {\n\t\t\treturn error('data is not an instanceof pattern',data,constructor,path)\n\t\t}\n\t}\n}\n\n/**\n * Runs the given test pattern on a value, if the test succeeds, it fails\n * the not() test.\n */\nexport function not(pattern) {\n\treturn function _not(data, root, path) {\n\t\tif (!fails(data, pattern, root, path)) {\n\t\t\treturn error('data matches pattern, when required not to', data, pattern, path)\n\t\t}\n\t}\n}\n\n/**\n * returns an array of problems if the data fails to satisfy \n * the assertions in the given pattern, false otherwise\n * @param {any} data    The data to match\n * @param {any} pattern The pattern to match\n * @param {any} root    Root object for assertions, set to data by default\n * @return {Array|false} Array with problems if the pattern fails, false otherwise\n */\nexport function fails(data, pattern, root, path='') {\n\tif (!root) {\n\t\troot = data\n\t}\n\tlet problems = []\n\tif (pattern === Boolean) {\n\t\tif (typeof data != 'boolean' && !(data instanceof Boolean)) {\n\t\t\tproblems.push(error('data is not a boolean', data, pattern, path))\n\t\t}\t\t\n\t} else if (pattern === Number) {\n\t\tif (typeof data != 'number' && !(data instanceof Number)) {\n\t\t\tproblems.push(error('data is not a number', data, pattern, path))\n\t\t}\n\t} else if (pattern === String) {\n\t\tif (typeof data != 'string' && !(data instanceof String)) {\n\t\t\tproblems.push(error('data is not a string', data, pattern, path))\n\t\t}\n\t\tif (data == \"\") {\n\t\t\tproblems.push(error('data is an empty string, which is not allowed', data, pattern, path))\n\t\t}\n\t} else if (pattern instanceof RegExp) {\n    \tif (Array.isArray(data)) {\n\t\t\tlet index = data.findIndex((element,index) => fails(element,pattern,root,path+'['+index+']'))\n            if (index>-1) {\n            \tproblems.push(error('data['+index+'] does not match pattern', data[index], pattern, path+'['+index+']'))\n            }\n        } else if (typeof data == 'undefined') {\n        \tproblems.push(error('data is undefined, should match pattern', data, pattern, path))\n    \t} else if (!pattern.test(data)) {\n        \tproblems.push(error('data does not match pattern', data, pattern, path))\n        }\n    } else if (pattern instanceof Function) {\n        let problem = pattern(data, root, path)\n        if (problem) {\n        \tif (Array.isArray(problem)) {\n        \t\tproblems = problems.concat(problem)\n        \t} else {\n\t        \tproblems.push(problem)\n\t        }\n        }\n    } else if (Array.isArray(pattern)) {\n\t\tif (!Array.isArray(data)) {\n\t\t\tproblems.push(error('data is not an array',data,[],path))\n\t\t}\n\t\tfor (let p of pattern) {\n\t\t\tfor (let index of data.keys()) {\n\t\t\t\tlet problem = fails(data[index], p, root, path+'['+index+']')\n\t\t\t\tif (Array.isArray(problem)) {\n\t\t\t\t\tproblems = problems.concat(problem)\n\t\t\t\t} else if (problem) {\n\t\t\t\t\tproblems.push(problem)\n\t\t\t\t}\n\t\t\t}\n    \t}\n    } else if (pattern && typeof pattern == 'object') {\n        if (Array.isArray(data)) {\n            let index = data.findIndex((element,index) => fails(element,pattern,root,path+'['+index+']'))\n            if (index>-1) {\n            \tproblems.push(error('data['+index+'] does not match pattern', data[index], pattern, path+'['+index+']'))\n            }\n        } else if (!data || typeof data != 'object') {\n        \tproblems.push(error('data is not an object, pattern is', data, pattern, path))\n        } else {\n        \tif (data instanceof URLSearchParams) {\n        \t\tdata = Object.fromEntries(data)\n        \t}\n        \tif (pattern instanceof Function) {\n        \t\tlet result = fails(data, pattern, root, path)\n\t            if (result) {\n\t            \tproblems = problems.concat(result)\n\t            }\n        \t} else {\n\t\t        for (const [wKey, wVal] of Object.entries(pattern)) {\n\t\t            let result = fails(data[wKey], wVal, root, path+'.'+wKey)\n\t\t            if (result) {\n\t\t            \tproblems = problems.concat(result)\n\t\t            }\n\t\t        }\n\t\t    }\n\t    }\n    } else {\n    \tif (pattern!=data) {\n    \t\tproblems.push(error('data and pattern are not equal', data, pattern, path))\n    \t}\n    }\n    if (problems.length) {\n    \treturn problems\n    }\n    return false\n}\n\n\n/**\n * Class used in assert() to add problems found and details to the error object\n */\nclass assertError extends Error {\n\tconstructor(message, problems, ...details) {\n\t\tsuper(message)\n\t\tthis.problems = problems\n\t\tthis.details = details\n\t}\n}\n\n/**\n * Returns an object with message, found and expected properties\n */ \nexport function error(message, found, expected, path, problems) {\n\tlet result = {\n\t\tmessage,\n\t\tfound,\n\t\texpected,\n\t\tpath\n\t}\n\tif (problems) {\n\t\tresult.problems = problems\n\t}\n\treturn result\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$2ddd80d1adc2ea42$exports","$2ddd80d1adc2ea42$export$d7c4a0dd6a4567e5","globalThis","assertEnabled","$2ddd80d1adc2ea42$export$e20fbacbb41798b","$2ddd80d1adc2ea42$export$a7a9523472993e97","source","test","problems","$2ddd80d1adc2ea42$export$478159de811fd37d","$2ddd80d1adc2ea42$var$assertError","$2ddd80d1adc2ea42$export$7acb7b24c478f9c6","pattern","data","root","path","$2ddd80d1adc2ea42$export$1788c381af06add2","$2ddd80d1adc2ea42$export$a3bc9b8ed74fc","$2ddd80d1adc2ea42$export$a83bcf183f49ea9","console","warn","$2ddd80d1adc2ea42$export$a9a18ae5ba42aeab","patterns","$2ddd80d1adc2ea42$export$b26c150f612c10f7","Array","isArray","value","$2ddd80d1adc2ea42$export$f632c79c8963a286","concat","filter","Boolean","length","$2ddd80d1adc2ea42$export$c6f1a4382426409f","URL","href","url","$2ddd80d1adc2ea42$export$9ab921aaffe56820","$2ddd80d1adc2ea42$export$ca03416d6c9e029e","constructor","$2ddd80d1adc2ea42$export$6003a5f097c73977","push","Number","String","RegExp","index","findIndex","element","Function","problem","p","keys","URLSearchParams","fromEntries","result","wKey","wVal","entries","Error","message","details","found","expected","assert"],"version":3,"file":"browser.js.map","sourceRoot":"../"}